{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to landcalc","text":"<p>A python package for geospatial analysis and mapping</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://acpotgieter.github.io/landcalc</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Create interactive maps</li> <li>Geospatial analysis</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#landcalc.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>landcalc/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/acpotgieter/landcalc/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>LandCalc could always use more documentation, whether as part of the official LandCalc docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/acpotgieter/landcalc/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up landcalc for local development.</p> <ol> <li> <p>Fork the landcalc repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/landcalc.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv landcalc\n$ cd landcalc/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 landcalc tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/acpotgieter/landcalc/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"foliumap/","title":"foliumap module","text":"<p>Adds custom Map class that extends the folium Map class.</p>"},{"location":"foliumap/#landcalc.foliumap.Map","title":"<code>Map</code>","text":"<p>               Bases: <code>Map</code></p> <p>A custom Map class that extends folium.Map.</p> Source code in <code>landcalc/foliumap.py</code> <pre><code>class Map(folium.Map):\n    \"\"\"A custom Map class that extends folium.Map.\"\"\"\n\n    def __init__(self, center=(0, 0), zoom=2, **kwargs):\n        \"\"\"Initializes the Map object.\n\n        Args:\n            center (tuple, optional): The initial center of the map as (latitude, longitude). Defaults to (0, 0).\n            zoom (int, optional): The initial zoom level of the map. Defaults to 2.\n            **kwargs: Additional keyword arguments for the folium.Map class.\n        \"\"\"\n        super().__init__(location=center, zoom_start=zoom, **kwargs)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n\n        geojson = folium.GeoJson(data=geojson, **kwargs)\n        geojson.add_to(self)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        folium.LayerControl().add_to(self)\n\n    def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n        \"\"\"Adds a split map to the map.\n\n        Args:\n            left (str, optional): The tile layer for the left side of the split map. Defaults to \"openstreetmap\".\n            right (str, optional): The tile layer for the right side of the split map. Defaults to \"cartodbpositron\".\n        \"\"\"\n        from localtileserver import get_folium_tile_layer\n\n        if left.startswith(\"http\") or os.path.exists(left):\n            layer_left = get_folium_tile_layer(left, **kwargs)\n        else:\n            layer_left = folium.TileLayer(left, overlay=True, **kwargs)\n        if right.startswith(\"http\") or os.path.exists(right):\n            layer_right = get_folium_tile_layer(right, **kwargs)\n        else:\n            layer_right = folium.TileLayer(right, overlay=True, **kwargs)\n\n        sbs = folium.plugins.SideBySideLayers(\n            layer_left=layer_left, layer_right=layer_right\n        )\n\n        layer_left.add_to(self)\n        layer_right.add_to(self)\n        sbs.add_to(self)\n\n    def add_basemap(self, basemap=\"OpenStreetMap\", **kwargs):\n        \"\"\"Adds a basemap to the map using a known provider name.\n\n        Args:\n            basemap (str): The name of the basemap to add.\n            **kwargs: Additional keyword arguments for the folium.TileLayer.\n        Raises:\n            ValueError: If the basemap name is not recognized.\n        \"\"\"\n\n        basemaps = {\n            \"OpenStreetMap\": {\n                \"tiles\": \"OpenStreetMap\",\n                \"attr\": \"\u00a9 OpenStreetMap contributors\",\n            },\n            \"Esri.WorldImagery\": {\n                \"tiles\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n                \"attr\": \"Tiles \u00a9 Esri\",\n            },\n            \"OpenTopoMap\": {\n                \"tiles\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",\n                \"attr\": \"\u00a9 OpenTopoMap contributors\",\n            },\n            \"CartoDB.Positron\": {\n                \"tiles\": \"https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png\",\n                \"attr\": \"\u00a9 CartoDB\",\n            },\n            \"Stamen.Terrain\": {\n                \"tiles\": \"https://stamen-tiles.a.ssl.fastly.net/terrain/{z}/{x}/{y}.jpg\",\n                \"attr\": \"Map tiles by Stamen Design, CC BY 3.0\",\n            },\n        }\n\n        if basemap not in basemaps:\n            raise ValueError(f\"Unsupported basemap: {basemap}\")\n\n        tile_info = basemaps[basemap]\n        tile_layer = folium.TileLayer(\n            tiles=tile_info[\"tiles\"],\n            attr=tile_info[\"attr\"],\n            name=basemap,\n            control=True,\n            **kwargs,\n        )\n        tile_layer.add_to(self)\n</code></pre>"},{"location":"foliumap/#landcalc.foliumap.Map.__init__","title":"<code>__init__(center=(0, 0), zoom=2, **kwargs)</code>","text":"<p>Initializes the Map object.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>The initial center of the map as (latitude, longitude). Defaults to (0, 0).</p> <code>(0, 0)</code> <code>zoom</code> <code>int</code> <p>The initial zoom level of the map. Defaults to 2.</p> <code>2</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.Map class.</p> <code>{}</code> Source code in <code>landcalc/foliumap.py</code> <pre><code>def __init__(self, center=(0, 0), zoom=2, **kwargs):\n    \"\"\"Initializes the Map object.\n\n    Args:\n        center (tuple, optional): The initial center of the map as (latitude, longitude). Defaults to (0, 0).\n        zoom (int, optional): The initial zoom level of the map. Defaults to 2.\n        **kwargs: Additional keyword arguments for the folium.Map class.\n    \"\"\"\n    super().__init__(location=center, zoom_start=zoom, **kwargs)\n</code></pre>"},{"location":"foliumap/#landcalc.foliumap.Map.add_basemap","title":"<code>add_basemap(basemap='OpenStreetMap', **kwargs)</code>","text":"<p>Adds a basemap to the map using a known provider name.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>The name of the basemap to add.</p> <code>'OpenStreetMap'</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.TileLayer.</p> <code>{}</code> Source code in <code>landcalc/foliumap.py</code> <pre><code>def add_basemap(self, basemap=\"OpenStreetMap\", **kwargs):\n    \"\"\"Adds a basemap to the map using a known provider name.\n\n    Args:\n        basemap (str): The name of the basemap to add.\n        **kwargs: Additional keyword arguments for the folium.TileLayer.\n    Raises:\n        ValueError: If the basemap name is not recognized.\n    \"\"\"\n\n    basemaps = {\n        \"OpenStreetMap\": {\n            \"tiles\": \"OpenStreetMap\",\n            \"attr\": \"\u00a9 OpenStreetMap contributors\",\n        },\n        \"Esri.WorldImagery\": {\n            \"tiles\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n            \"attr\": \"Tiles \u00a9 Esri\",\n        },\n        \"OpenTopoMap\": {\n            \"tiles\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",\n            \"attr\": \"\u00a9 OpenTopoMap contributors\",\n        },\n        \"CartoDB.Positron\": {\n            \"tiles\": \"https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png\",\n            \"attr\": \"\u00a9 CartoDB\",\n        },\n        \"Stamen.Terrain\": {\n            \"tiles\": \"https://stamen-tiles.a.ssl.fastly.net/terrain/{z}/{x}/{y}.jpg\",\n            \"attr\": \"Map tiles by Stamen Design, CC BY 3.0\",\n        },\n    }\n\n    if basemap not in basemaps:\n        raise ValueError(f\"Unsupported basemap: {basemap}\")\n\n    tile_info = basemaps[basemap]\n    tile_layer = folium.TileLayer(\n        tiles=tile_info[\"tiles\"],\n        attr=tile_info[\"attr\"],\n        name=basemap,\n        control=True,\n        **kwargs,\n    )\n    tile_layer.add_to(self)\n</code></pre>"},{"location":"foliumap/#landcalc.foliumap.Map.add_gdf","title":"<code>add_gdf(gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>landcalc/foliumap.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliumap/#landcalc.foliumap.Map.add_geojson","title":"<code>add_geojson(data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.GeoJson layer.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>landcalc/foliumap.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n\n    geojson = folium.GeoJson(data=geojson, **kwargs)\n    geojson.add_to(self)\n</code></pre>"},{"location":"foliumap/#landcalc.foliumap.Map.add_layer_control","title":"<code>add_layer_control()</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>landcalc/foliumap.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"foliumap/#landcalc.foliumap.Map.add_shp","title":"<code>add_shp(data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>landcalc/foliumap.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliumap/#landcalc.foliumap.Map.add_split_map","title":"<code>add_split_map(left='openstreetmap', right='cartodbpositron', **kwargs)</code>","text":"<p>Adds a split map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>The tile layer for the left side of the split map. Defaults to \"openstreetmap\".</p> <code>'openstreetmap'</code> <code>right</code> <code>str</code> <p>The tile layer for the right side of the split map. Defaults to \"cartodbpositron\".</p> <code>'cartodbpositron'</code> Source code in <code>landcalc/foliumap.py</code> <pre><code>def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n    \"\"\"Adds a split map to the map.\n\n    Args:\n        left (str, optional): The tile layer for the left side of the split map. Defaults to \"openstreetmap\".\n        right (str, optional): The tile layer for the right side of the split map. Defaults to \"cartodbpositron\".\n    \"\"\"\n    from localtileserver import get_folium_tile_layer\n\n    if left.startswith(\"http\") or os.path.exists(left):\n        layer_left = get_folium_tile_layer(left, **kwargs)\n    else:\n        layer_left = folium.TileLayer(left, overlay=True, **kwargs)\n    if right.startswith(\"http\") or os.path.exists(right):\n        layer_right = get_folium_tile_layer(right, **kwargs)\n    else:\n        layer_right = folium.TileLayer(right, overlay=True, **kwargs)\n\n    sbs = folium.plugins.SideBySideLayers(\n        layer_left=layer_left, layer_right=layer_right\n    )\n\n    layer_left.add_to(self)\n    layer_right.add_to(self)\n    sbs.add_to(self)\n</code></pre>"},{"location":"foliumap/#landcalc.foliumap.Map.add_vector","title":"<code>add_vector(data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>landcalc/foliumap.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install LandCalc, run this command in your terminal:</p> <pre><code>pip install landcalc\n</code></pre> <p>This is the preferred method to install LandCalc, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install LandCalc from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/acpotgieter/landcalc\n</code></pre>"},{"location":"landcalc/","title":"landcalc module","text":"<p>Main module.</p>"},{"location":"landcalc/#landcalc.landcalc.Map","title":"<code>Map</code>","text":"<p>               Bases: <code>Map</code></p> Source code in <code>landcalc/landcalc.py</code> <pre><code>class Map(ipyleaflet.Map):\n    def __init__(self, center=[20, 0], zoom=2, height=\"600px\", **kwargs):\n\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n\n    def add_basemap(self, basemap=\"OpenTopoMap\"):\n        basemap_urls = {\n            \"OpenStreetMap.Mapnik\": \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"OpenTopoMap\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",\n            \"Esri.WorldImagery\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n            \"CartoDB.DarkMatter\": \"https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png\",\n        }\n\n        if basemap not in basemap_urls:\n            raise ValueError(f\"Unsupported basemap: {basemap}\")\n\n        url = basemap_urls[basemap]\n        layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_basemap_gui(self, options=None, position=\"topright\"):\n        if options is None:\n            options = [\n                \"OpenStreetMap.Mapnik\",\n                \"OpenTopoMap\",\n                \"Esri.WorldImagery\",\n                \"CartoDB.DarkMatter\",\n            ]\n\n        toggle = widgets.ToggleButton(\n            value=True,\n            button_style=\"\",\n            tooltip=\"Click me\",\n            icon=\"map\",\n        )\n        toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        dropdown = widgets.Dropdown(\n            options=options,\n            value=options[0],\n            description=\"Basemap:\",\n            style={\"description_width\": \"initial\"},\n        )\n        dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n        button = widgets.Button(\n            icon=\"times\",\n        )\n        button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        hbox = widgets.HBox([toggle, dropdown, button])\n\n        def on_toggle_change(change):\n            if change[\"new\"]:\n                hbox.children = [toggle, dropdown, button]\n            else:\n                hbox.children = [toggle]\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        def on_button_click(b):\n            hbox.close()\n            toggle.close()\n            dropdown.close()\n            button.close()\n\n        button.on_click(on_button_click)\n\n        def on_dropdown_change(change):\n            if change[\"new\"]:\n                self.layers = self.layers[:-2]\n                self.add_basemap(change[\"new\"])\n\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n        self.add(control)\n\n    def add_split_map(\n        self, left_layer=\"OpenStreetMap.Mapnik\", right_layer=\"Esri.WorldImagery\"\n    ):\n        \"\"\"Adds a split map control to the map.\n\n        Args:\n            left_layer (str): The tile layer name for the left side. Default is \"OpenStreetMap.Mapnik\".\n            right_layer (str): The tile layer name for the right side. Default is \"Esri.WorldImagery\".\n        \"\"\"\n        basemaps = {\n            \"OpenStreetMap.Mapnik\": \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"OpenTopoMap\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",\n            \"Esri.WorldImagery\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n            \"CartoDB.DarkMatter\": \"https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png\",\n        }\n\n        if left_layer not in basemaps or right_layer not in basemaps:\n            raise ValueError(\n                \"Basemap not supported. Check spelling or add it to the dictionary.\"\n            )\n\n        left = ipyleaflet.TileLayer(url=basemaps[left_layer], name=left_layer)\n        right = ipyleaflet.TileLayer(url=basemaps[right_layer], name=right_layer)\n\n        self.add(left)\n        self.add(right)\n\n        control = ipyleaflet.SplitMapControl(left_layer=left, right_layer=right)\n        self.add(control)\n\n    def add_widget(self, widget, position=\"topright\", **kwargs):\n        \"\"\"Add a widget to the map.\"\"\"\n        control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n        self.add(control)\n\n    def add_google_map(self, map_type=\"ROADMAP\"):\n        \"\"\"Add Google Map to the map.\n\n        Args:\n            map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n        \"\"\"\n        map_types = {\n            \"ROADMAP\": \"m\",\n            \"SATELLITE\": \"s\",\n            \"HYBRID\": \"y\",\n            \"TERRAIN\": \"p\",\n        }\n        map_type = map_types[map_type.upper()]\n\n        url = (\n            f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n        )\n        layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n        self.add(layer)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n        layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n        self.add_layer(layer)\n\n        if zoom_to_layer:\n            bounds = gdf.total_bounds\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(control)\n\n    def add_raster(self, filepath, **kwargs):\n\n        from localtileserver import TileClient, get_leaflet_tile_layer\n\n        client = TileClient(filepath)\n        tile_layer = get_leaflet_tile_layer(client, **kwargs)\n\n        self.add(tile_layer)\n        self.center = client.center()\n        self.zoom = client.default_zoom\n\n    def add_image(self, image, bounds=None, **kwargs):\n        \"\"\"Adds an image to the map.\n\n        Args:\n            image (str): The file path to the image.\n            bounds (list, optional): The bounds for the image. Defaults to None.\n            **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n        \"\"\"\n\n        if bounds is None:\n            bounds = [[-90, -180], [90, 180]]\n        overlay = ipyleaflet.ImageOverlay(url=image, bounds=bounds, **kwargs)\n        self.add(overlay)\n\n    def add_video(self, video, bounds=None, **kwargs):\n        \"\"\"Adds a video to the map.\n\n        Args:\n            video (str): The file path to the video.\n            bounds (list, optional): The bounds for the video. Defaults to None.\n            **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n        \"\"\"\n\n        if bounds is None:\n            bounds = [[-90, -180], [90, 180]]\n        overlay = ipyleaflet.VideoOverlay(url=video, bounds=bounds, **kwargs)\n        self.add(overlay)\n\n    def add_wms_layer(\n        self, url, layers, format=\"image/png\", transparent=True, **kwargs\n    ):\n        \"\"\"Adds a WMS layer to the map.\n\n        Args:\n            url (str): The WMS service URL.\n            layers (str): The layers to display.\n            **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n        \"\"\"\n        layer = ipyleaflet.WMSLayer(\n            url=url, layers=layers, format=format, transparent=transparent, **kwargs\n        )\n        self.add(layer)\n</code></pre>"},{"location":"landcalc/#landcalc.landcalc.Map.add_gdf","title":"<code>add_gdf(gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>landcalc/landcalc.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"landcalc/#landcalc.landcalc.Map.add_geojson","title":"<code>add_geojson(data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>landcalc/landcalc.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n    layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n    self.add_layer(layer)\n\n    if zoom_to_layer:\n        bounds = gdf.total_bounds\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"landcalc/#landcalc.landcalc.Map.add_google_map","title":"<code>add_google_map(map_type='ROADMAP')</code>","text":"<p>Add Google Map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>Map type. Defaults to \"ROADMAP\".</p> <code>'ROADMAP'</code> Source code in <code>landcalc/landcalc.py</code> <pre><code>def add_google_map(self, map_type=\"ROADMAP\"):\n    \"\"\"Add Google Map to the map.\n\n    Args:\n        map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n    \"\"\"\n    map_types = {\n        \"ROADMAP\": \"m\",\n        \"SATELLITE\": \"s\",\n        \"HYBRID\": \"y\",\n        \"TERRAIN\": \"p\",\n    }\n    map_type = map_types[map_type.upper()]\n\n    url = (\n        f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n    )\n    layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n    self.add(layer)\n</code></pre>"},{"location":"landcalc/#landcalc.landcalc.Map.add_image","title":"<code>add_image(image, bounds=None, **kwargs)</code>","text":"<p>Adds an image to the map.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The file path to the image.</p> required <code>bounds</code> <code>list</code> <p>The bounds for the image. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.ImageOverlay layer.</p> <code>{}</code> Source code in <code>landcalc/landcalc.py</code> <pre><code>def add_image(self, image, bounds=None, **kwargs):\n    \"\"\"Adds an image to the map.\n\n    Args:\n        image (str): The file path to the image.\n        bounds (list, optional): The bounds for the image. Defaults to None.\n        **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n    \"\"\"\n\n    if bounds is None:\n        bounds = [[-90, -180], [90, 180]]\n    overlay = ipyleaflet.ImageOverlay(url=image, bounds=bounds, **kwargs)\n    self.add(overlay)\n</code></pre>"},{"location":"landcalc/#landcalc.landcalc.Map.add_layer_control","title":"<code>add_layer_control()</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>landcalc/landcalc.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"landcalc/#landcalc.landcalc.Map.add_shp","title":"<code>add_shp(data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>landcalc/landcalc.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"landcalc/#landcalc.landcalc.Map.add_split_map","title":"<code>add_split_map(left_layer='OpenStreetMap.Mapnik', right_layer='Esri.WorldImagery')</code>","text":"<p>Adds a split map control to the map.</p> <p>Parameters:</p> Name Type Description Default <code>left_layer</code> <code>str</code> <p>The tile layer name for the left side. Default is \"OpenStreetMap.Mapnik\".</p> <code>'OpenStreetMap.Mapnik'</code> <code>right_layer</code> <code>str</code> <p>The tile layer name for the right side. Default is \"Esri.WorldImagery\".</p> <code>'Esri.WorldImagery'</code> Source code in <code>landcalc/landcalc.py</code> <pre><code>def add_split_map(\n    self, left_layer=\"OpenStreetMap.Mapnik\", right_layer=\"Esri.WorldImagery\"\n):\n    \"\"\"Adds a split map control to the map.\n\n    Args:\n        left_layer (str): The tile layer name for the left side. Default is \"OpenStreetMap.Mapnik\".\n        right_layer (str): The tile layer name for the right side. Default is \"Esri.WorldImagery\".\n    \"\"\"\n    basemaps = {\n        \"OpenStreetMap.Mapnik\": \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",\n        \"OpenTopoMap\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",\n        \"Esri.WorldImagery\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n        \"CartoDB.DarkMatter\": \"https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png\",\n    }\n\n    if left_layer not in basemaps or right_layer not in basemaps:\n        raise ValueError(\n            \"Basemap not supported. Check spelling or add it to the dictionary.\"\n        )\n\n    left = ipyleaflet.TileLayer(url=basemaps[left_layer], name=left_layer)\n    right = ipyleaflet.TileLayer(url=basemaps[right_layer], name=right_layer)\n\n    self.add(left)\n    self.add(right)\n\n    control = ipyleaflet.SplitMapControl(left_layer=left, right_layer=right)\n    self.add(control)\n</code></pre>"},{"location":"landcalc/#landcalc.landcalc.Map.add_vector","title":"<code>add_vector(data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>landcalc/landcalc.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"landcalc/#landcalc.landcalc.Map.add_video","title":"<code>add_video(video, bounds=None, **kwargs)</code>","text":"<p>Adds a video to the map.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>str</code> <p>The file path to the video.</p> required <code>bounds</code> <code>list</code> <p>The bounds for the video. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.VideoOverlay layer.</p> <code>{}</code> Source code in <code>landcalc/landcalc.py</code> <pre><code>def add_video(self, video, bounds=None, **kwargs):\n    \"\"\"Adds a video to the map.\n\n    Args:\n        video (str): The file path to the video.\n        bounds (list, optional): The bounds for the video. Defaults to None.\n        **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n    \"\"\"\n\n    if bounds is None:\n        bounds = [[-90, -180], [90, 180]]\n    overlay = ipyleaflet.VideoOverlay(url=video, bounds=bounds, **kwargs)\n    self.add(overlay)\n</code></pre>"},{"location":"landcalc/#landcalc.landcalc.Map.add_widget","title":"<code>add_widget(widget, position='topright', **kwargs)</code>","text":"<p>Add a widget to the map.</p> Source code in <code>landcalc/landcalc.py</code> <pre><code>def add_widget(self, widget, position=\"topright\", **kwargs):\n    \"\"\"Add a widget to the map.\"\"\"\n    control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n    self.add(control)\n</code></pre>"},{"location":"landcalc/#landcalc.landcalc.Map.add_wms_layer","title":"<code>add_wms_layer(url, layers, format='image/png', transparent=True, **kwargs)</code>","text":"<p>Adds a WMS layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The WMS service URL.</p> required <code>layers</code> <code>str</code> <p>The layers to display.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.WMSLayer layer.</p> <code>{}</code> Source code in <code>landcalc/landcalc.py</code> <pre><code>def add_wms_layer(\n    self, url, layers, format=\"image/png\", transparent=True, **kwargs\n):\n    \"\"\"Adds a WMS layer to the map.\n\n    Args:\n        url (str): The WMS service URL.\n        layers (str): The layers to display.\n        **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n    \"\"\"\n    layer = ipyleaflet.WMSLayer(\n        url=url, layers=layers, format=format, transparent=transparent, **kwargs\n    )\n    self.add(layer)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use LandCalc in a project:</p> <pre><code>import landcalc\n</code></pre>"},{"location":"examples/foliumap/","title":"Foliumap","text":"In\u00a0[1]: Copied! <pre>import landcalc.foliumap as landcalc\n</pre> import landcalc.foliumap as landcalc In\u00a0[2]: Copied! <pre>m = landcalc.Map()\nm\n</pre> m = landcalc.Map() m Out[2]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[3]: Copied! <pre>m = landcalc.Map()\nm.add_basemap(\"OpenTopoMap\")\nm\n</pre> m = landcalc.Map() m.add_basemap(\"OpenTopoMap\") m Out[3]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[4]: Copied! <pre>m = landcalc.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_basemap(\"CartoDB.Positron\")\nm.add_basemap(\"Esri.WorldImagery\")\nm.add_layer_control()\nm\n</pre> m = landcalc.Map() m.add_basemap(\"OpenTopoMap\") m.add_basemap(\"CartoDB.Positron\") m.add_basemap(\"Esri.WorldImagery\") m.add_layer_control() m Out[4]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[5]: Copied! <pre>url = \"https://raw.githubusercontent.com/johan/world.geo.json/master/countries/USA/CA.geo.json\"\n\nm = landcalc.Map(center=(37.0, -119.5), zoom=6)\nm.add_basemap(\"OpenTopoMap\")\nm.add_vector(url)\nm\n</pre> url = \"https://raw.githubusercontent.com/johan/world.geo.json/master/countries/USA/CA.geo.json\"  m = landcalc.Map(center=(37.0, -119.5), zoom=6) m.add_basemap(\"OpenTopoMap\") m.add_vector(url) m Out[5]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/foliumap/#general-map-usage","title":"General Map Usage\u00b6","text":""},{"location":"examples/foliumap/#basic-map-creation","title":"Basic Map Creation\u00b6","text":""},{"location":"examples/foliumap/#add-basemap","title":"Add Basemap\u00b6","text":""},{"location":"examples/foliumap/#using-layer-control","title":"Using Layer Control\u00b6","text":""},{"location":"examples/foliumap/#using-add-vector","title":"Using Add Vector\u00b6","text":""},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print(\"Hello World!\")\n</pre> print(\"Hello World!\") <pre>Hello World!\n</pre>"},{"location":"examples/ipyleaflet/","title":"Ipyleaflet","text":"In\u00a0[1]: Copied! <pre>import landcalc\n</pre> import landcalc In\u00a0[2]: Copied! <pre>m = landcalc.Map()\nm\n</pre> m = landcalc.Map() m Out[2]:"},{"location":"examples/splitmap/","title":"Splitmap","text":"In\u00a0[1]: Copied! <pre>import landcalc.foliumap as landcalc\n</pre> import landcalc.foliumap as landcalc In\u00a0[2]: Copied! <pre>m = landcalc.Map()\nm.add_split_map()\nm\n</pre> m = landcalc.Map() m.add_split_map() m Out[2]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[3]: Copied! <pre>import landcalc as landcalc\n</pre> import landcalc as landcalc In\u00a0[4]: Copied! <pre>m = landcalc.Map()\nm.add_split_map()\nm\n</pre> m = landcalc.Map() m.add_split_map() m Out[4]: In\u00a0[5]: Copied! <pre>m = landcalc.Map(center=[37.7749, -122.4194], zoom=10)\nm.add_split_map(\"OpenStreetMap.Mapnik\", \"Esri.WorldImagery\")\nm.add_layer_control()\nm\n</pre> m = landcalc.Map(center=[37.7749, -122.4194], zoom=10) m.add_split_map(\"OpenStreetMap.Mapnik\", \"Esri.WorldImagery\") m.add_layer_control() m Out[5]:"},{"location":"examples/splitmap/#basic-split-map-folium-base","title":"Basic Split Map: Folium Base\u00b6","text":""},{"location":"examples/splitmap/#basic-split-map-landcalc-base","title":"Basic Split Map: LandCalc Base\u00b6","text":""},{"location":"examples/splitmap/#example","title":"Example\u00b6","text":""}]}